<!doctype html>
<meta charset="utf-8">
  <title>x, y, y * 087 | GIF</title>
  
  <!-- Basic Metadata -->
  <meta name="description" content="Convert X, Y, Z point cloud coordinates into OBJ/GLTF with Funebra Math-Art Engine." />
  <meta name="keywords" content="Funebra, math art engine, point cloud converter, OBJ, GLTF, 3D viewer, geometry" />
  <meta name="author" content="Funebra / pLabs Entertainment" />

  <!-- Open Graph (Facebook, LinkedIn) -->
  <meta property="og:title" content="Funebra Math-Art Engine – 3D Point Cloud Converter" />
  <meta property="og:description" content="Paste your coordinates (x, y, z) and export to OBJ or GLTF instantly." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://funebra.github.io/math-art-engine/" />
  <meta property="og:image" content="https://funebra.github.io/math-art-engine/compatibility092025.png" />

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Funebra Math-Art Engine – 3D Point Cloud Converter" />
  <meta name="twitter:description" content="Paste coordinates and generate OBJ/GLTF instantly." />
  <meta name="twitter:image" content="https://funebra.github.io/math-art-engine/compatibility092025.png" />

<style>
  .row{display:flex;gap:.5rem;align-items:center;margin:.35rem 0}
  .row label{white-space:nowrap}
  body{font:14px system-ui,Segoe UI,Roboto;margin:20px}
  textarea{width:100%;height:220px}
  .row{display:flex;gap:8px;align-items:center;margin:8px 0}
  input[type=number]{width:100px}
  button{padding:6px 10px;border-radius:8px;border:1px solid #ccc;background:#fafafa;cursor:pointer}
</style>
<h3>Paste your lines (format: <code>v x, y, y</code>)</h3>
<textarea id="src"></textarea>
<div class="row">
  <label>Thickness:</label><input id="th" type="number" value="20" step="1">
  <label>Triangulation:</label>
  <select id="tri">
    <option value="earclip" selected>Ear-clip (safe)</option>
    <option value="fan">Fan (convex)</option>
  </select>
  <button id="toOBJ">Export OBJ</button>
  <button id="toGLTF">Export glTF</button>
</div>
<div class="row">
  <label><input id="closeLoop" type="checkbox"> Close loop</label>
  <label><input id="swapYZ" type="checkbox"> Swap Y/Z</label>
  <label><input id="invertY" type="checkbox"> Invert Y</label>
</div>
<div class="row">
  <button id="btnOBJpoints">Export OBJ (Points)</button>
  <button id="btnOBJwire">Export OBJ (Wireframe)</button>
  <!-- your existing Export OBJ / Export glTF buttons can stay -->
</div>
<pre id="convMsg" style="opacity:.8"></pre>
<pre id="msg"></pre>
<script>
const TAU=Math.PI*2;
function dl(name,text){const b=new Blob([text],{type:"text/plain"}),u=URL.createObjectURL(b);const a=document.createElement("a");a.href=u;a.download=name;document.body.appendChild(a);a.click();a.remove();setTimeout(()=>URL.revokeObjectURL(u),1000);}

function parseList(txt){
  const pts=[];
  for (const line of txt.split(/\r?\n/)){
    const m = line.match(/^v\s*([-\d.]+)\s*,\s*([-\d.]+)\s*,\s*([-\d.]+)/i);
    if (!m) continue;
    const x=+m[1], y=+m[2];
    pts.push({x,y});
  }
  return pts;
}

// orientation helpers
function doubleArea(pts){let a=0;for(let i=0;i<pts.length;i++){const j=(i+1)%pts.length;a+=pts[i].x*pts[j].y-pts[j].x*pts[i].y;}return a;}
function ensureCCW(pts){return doubleArea(pts)<0?[...pts].reverse():pts;}

// ear-clip
function isConvex(a,b,c){return ((b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x))>0;}
function pInTri(p,a,b,c){const v0={x:c.x-a.x,y:c.y-a.y},v1={x:b.x-a.x,y:b.y-a.y},v2={x:p.x-a.x,y:p.y-a.y};
  const d00=v0.x*v0.x+v0.y*v0.y,d01=v0.x*v1.x+v0.y*v1.y,d02=v0.x*v2.x+v0.y*v2.y,d11=v1.x*v1.x+v1.y*v1.y,d12=v1.x*v2.x+v1.y*v2.y;
  const inv=1/(d00*d11-d01*d01||1); const u=(d11*d02-d01*d12)*inv, v=(d00*d12-d01*d02)*inv; return u>=0&&v>=0&&u+v<=1;}
function earclip(poly){const n=poly.length,V=Array.from({length:n},(_,i)=>i),tris=[];let guard=0;
  while(V.length>2 && guard++<10000){let done=false;for(let i=0;i<V.length;i++){const ia=V[(i-1+V.length)%V.length],ib=V[i],ic=V[(i+1)%V.length];
    const A=poly[ia],B=poly[ib],C=poly[ic]; if(!isConvex(A,B,C))continue; let inside=false;
    for(let k=0;k<V.length;k++){const idx=V[k]; if(idx===ia||idx===ib||idx===ic)continue; if(pInTri(poly[idx],A,B,C)){inside=true;break;}}
    if(inside)continue; tris.push([ia,ib,ic]); V.splice(i,1); done=true; break;} if(!done) break;}
  return tris;
}

function prismFromPolygon(points,{z0=-10,z1=10,tri="earclip"}={}){
  const poly=ensureCCW(points), n=poly.length;
  const pos=[], nor=[], idx=[]; const cx=poly.reduce((s,p)=>s+p.x,0)/n, cy=poly.reduce((s,p)=>s+p.y,0)/n;

  // top
  const topC=pos.length/3; pos.push(cx,cy,z1); nor.push(0,0,1);
  const topStart=pos.length/3; for(const p of poly){pos.push(p.x,p.y,z1); nor.push(0,0,1);}
  if(tri==="fan"){for(let i=0;i<n;i++){idx.push(topC, topStart+i, topStart+((i+1)%n));}}
  else {for(const [a,b,c] of earclip(poly)) idx.push(topStart+a, topStart+b, topStart+c);}

  // bottom
  const botC=pos.length/3; pos.push(cx,cy,z0); nor.push(0,0,-1);
  const botStart=pos.length/3; for(const p of poly){pos.push(p.x,p.y,z0); nor.push(0,0,-1);}
  if(tri==="fan"){for(let i=0;i<n;i++){idx.push(botC, botStart+((i+1)%n), botStart+i);}}
  else {for(const [a,b,c] of earclip(poly)) idx.push(botStart+c, botStart+b, botStart+a);}

  // sides
  for(let i=0;i<n;i++){
    const a=poly[i], b=poly[(i+1)%n]; const ex=b.x-a.x, ey=b.y-a.y, L=Math.hypot(ex,ey)||1; const nx=ey/L, ny=-ex/L;
    const ta=pos.length/3; pos.push(a.x,a.y,z1); nor.push(nx,ny,0);
    const tb=pos.length/3; pos.push(b.x,b.y,z1); nor.push(nx,ny,0);
    const bb=pos.length/3; pos.push(b.x,b.y,z0); nor.push(nx,ny,0);
    const ba=pos.length/3; pos.push(a.x,a.y,z0); nor.push(nx,ny,0);
    idx.push(ta,tb,bb,  ta,bb,ba);
  }
  return {positions:new Float32Array(pos), normals:new Float32Array(nor), indices:new Uint32Array(idx)};
}

function toOBJ(mesh){
  const {positions,indices}=mesh, v=[], f=[];
  for(let i=0;i<positions.length;i+=3) v.push(`v ${positions[i]} ${positions[i+1]} ${positions[i+2]}`);
  for(let i=0;i<indices.length;i+=3)   f.push(`f ${indices[i]+1} ${indices[i+1]+1} ${indices[i+2]+1}`);
  return `# OBJ from converter\n${v.join('\n')}\n${f.join('\n')}\n`;
}

function toBase64(ab){let s='';const b=new Uint8Array(ab);for(let i=0;i<b.length;i++)s+=String.fromCharCode(b[i]);return btoa(s);}
function minMax3(a){const mn=[+1/0,+1/0,+1/0],mx=[-1/0,-1/0,-1/0];for(let i=0;i<a.length;i+=3){mn[0]=Math.min(mn[0],a[i]);mx[0]=Math.max(mx[0],a[i]);mn[1]=Math.min(mn[1],a[i+1]);mx[1]=Math.max(mx[1],a[i+1]);mn[2]=Math.min(mn[2],a[i+2]);mx[2]=Math.max(mx[2],a[i+2]);}return{min:mn,max:mx};}
function toGLTF(mesh){
  const {positions,normals,indices}=mesh;
  const posB=positions.byteLength, norB=normals.byteLength, idxB=indices.byteLength;
  const buf=new Uint8Array(posB+norB+idxB);
  buf.set(new Uint8Array(positions.buffer),0);
  buf.set(new Uint8Array(normals.buffer),posB);
  buf.set(new Uint8Array(indices.buffer),posB+norB);
  const uri=`data:application/octet-stream;base64,${toBase64(buf.buffer)}`;
  const mm=minMax3(positions);
  return JSON.stringify({
    asset:{version:"2.0",generator:"converter"},
    buffers:[{byteLength:buf.byteLength,uri}],
    bufferViews:[
      {buffer:0,byteOffset:0,byteLength:posB,target:34962},
      {buffer:0,byteOffset:posB,byteLength:norB,target:34962},
      {buffer:0,byteOffset:posB+norB,byteLength:idxB,target:34963}
    ],
    accessors:[
      {bufferView:0,byteOffset:0,componentType:5126,count:positions.length/3,type:"VEC3",min:mm.min,max:mm.max},
      {bufferView:1,byteOffset:0,componentType:5126,count:normals.length/3,type:"VEC3"},
      {bufferView:2,byteOffset:0,componentType:5125,count:indices.length,type:"SCALAR"}
    ],
    meshes:[{primitives:[{attributes:{POSITION:0,NORMAL:1},indices:2}]}],
    nodes:[{mesh:0,name:"Prism"}],
    scenes:[{nodes:[0]}],scene:0
  });
}

const src=document.getElementById('src'), th=document.getElementById('th'), tri=document.getElementById('tri'), msg=document.getElementById('msg');
document.getElementById('toOBJ').onclick=()=>{
  const pts=parseList(src.value); if(!pts.length){msg.textContent='No points parsed.';return;}
  const h=+th.value||20; const mesh=prismFromPolygon(pts,{z0:-h/2,z1:h/2,tri:tri.value});
  dl('shape.obj', toOBJ(mesh)); msg.textContent=`OBJ exported with ${pts.length} outline vertices.`;
};
document.getElementById('toGLTF').onclick=()=>{
  const pts=parseList(src.value); if(!pts.length){msg.textContent='No points parsed.';return;}
  const h=+th.value||20; const mesh=prismFromPolygon(pts,{z0:-h/2,z1:h/2,tri:tri.value});
  dl('shape.gltf', toGLTF(mesh)); msg.textContent=`glTF exported with ${pts.length} outline vertices.`;
};
















/* ---------- Robust parser: accepts "v x, y, z" or "x, y, z" or spaced ---------- */
function parseXYZ(text){
  const pts=[];
  const lines = text.split(/\r?\n/);
  for (let line of lines){
    line = line.trim();
    if (!line) continue;
    line = line.replace(/^[vV]\s+/, '');     // drop optional leading 'v'
    line = line.replace(/[,;]+/g, ' ');      // commas/semicolons -> spaces
    const nums = line.match(/[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?/g);
    if (!nums || nums.length < 2) continue;
    const x = +nums[0], y = +nums[1], z = (nums[2]!==undefined) ? +nums[2] : 0;
    pts.push([x,y,z]);
  }
  return pts;
}

/* ---------- Optional transforms ---------- */
function applyTransforms(pts, opts){
  const out = [];
  for (const p of pts){
    let [x,y,z]=p;
    if (opts.swapYZ){ [y,z] = [z,y]; }
    if (opts.invertY){ y = -y; }
    out.push([x,y,z]);
  }
  return out;
}

/* ---------- OBJ exporters ---------- */
function objPoints(pts){
  let s = '# funebra points\no funebra_points\n';
  s += pts.map(p=>`v ${p[0]} ${p[1]} ${p[2]}`).join('\n')+'\n';
  s += 'p '+ pts.map((_,i)=>i+1).join(' ') + '\n';
  return s;
}
function objWirePolyline(pts, closeLoop){
  let s = '# funebra wireframe (polyline)\no funebra_lines\n';
  s += pts.map(p=>`v ${p[0]} ${p[1]} ${p[2]}`).join('\n')+'\n';
  s += 'l ' + pts.map((_,i)=>i+1).join(' ') + (closeLoop ? ` 1` : '') + '\n';
  return s;
}

/* ---------- Thick ribbon (mesh) from 2D outline + triangulation ---------- */
/* Keep your existing “Thickness” + “Triangulation” if you already have them.
   If not, here’s a compact version you can wire in. */
function buildRibbonMesh2D(pts, thickness=20, closeLoop=true){
  // treat z constant; offset in XY plane
  const n = pts.length;
  if (n<2) return {V:[],F:[]};
  // compute vertex normals (polyline)
  const norm = new Array(n).fill(0).map(_=>[0,0]);
  function addNorm(i, dx,dy){
    const len = Math.hypot(dx,dy)||1;
    const nx = -dy/len, ny = dx/len; // left normal
    norm[i][0]+=nx; norm[i][1]+=ny;
  }
  for(let i=0;i<n-1;i++){
    const [x1,y1]=pts[i], [x2,y2]=pts[i+1];
    addNorm(i, x2-x1, y2-y1);
    addNorm(i+1, x2-x1, y2-y1);
  }
  if (closeLoop){
    const [x1,y1]=pts[n-1], [x2,y2]=pts[0];
    addNorm(n-1, x2-x1, y2-y1);
    addNorm(0,      x2-x1, y2-y1);
  }
  // build two rails L/R
  const h = thickness/2;
  const L=[], R=[];
  for(let i=0;i<n;i++){
    let [x,y,z]=pts[i];
    const nx=norm[i][0], ny=norm[i][1];
    const nl = Math.hypot(nx,ny)||1;
    const ux=nx/nl, uy=ny/nl;
    L.push([x+ux*h, y+uy*h, z]);
    R.push([x-ux*h, y-uy*h, z]);
  }
  // vertices: all L then all R
  const V = L.concat(R);
  const F = [];
  const m = n-1;
  const wrap = (i, N)=> (i%N+N)%N;
  const last = closeLoop ? n : n-1;
  for(let i=0;i<last-1+ (closeLoop?1:0); i++){
    const a = i, b = wrap(i+1,n);
    const a2 = a+n, b2 = b+n;
    // quad (a,a2,b2,b) -> two tris
    F.push([a,a2,b2], [a,b2,b]);
  }
  return {V,F};
}
function objMesh(V,F){
  let s = '# funebra mesh\no funebra_mesh\n';
  s += V.map(v=>`v ${v[0]} ${v[1]} ${v[2]}`).join('\n')+'\n';
  s += F.map(f=>`f ${f[0]+1} ${f[1]+1} ${f[2]+1}`).join('\n')+'\n';
  return s;
}

/* ---------- Minimal ear-clip (simple polygon, no holes) ---------- */
function earclipTriangulate2D(poly){ // poly: [ [x,y,z], ... ]
  // project to XY
  const P = poly.map(p=>[p[0],p[1]]);
  const n = P.length; if (n<3) return [];
  const V = [...Array(n).keys()];
  // orientation
  function area(){ let a=0; for(let i=0;i<n;i++){const j=(i+1)%n; a+=P[i][0]*P[j][1]-P[j][0]*P[i][1];} return a/2; }
  const ccw = area()>0;
  if (!ccw){ V.reverse(); }
  function triArea(a,b,c){return (P[b][0]-P[a][0])*(P[c][1]-P[a][1])-(P[c][0]-P[a][0])*(P[b][1]-P[a][1]);}
  function insideTri(ax,ay,bx,by,cx,cy,px,py){
    const v0x=cx-ax, v0y=cy-ay, v1x=bx-ax, v1y=by-ay, v2x=px-ax, v2y=py-ay;
    const dot00=v0x*v0x+v0y*v0y, dot01=v0x*v1x+v0y*v1y, dot02=v0x*v2x+v0y*v2y;
    const dot11=v1x*v1x+v1y*v1y, dot12=v1x*v2x+v1y*v2y;
    const inv = 1/((dot00*dot11)-(dot01*dot01));
    const u = ((dot11*dot02)-(dot01*dot12))*inv;
    const v = ((dot00*dot12)-(dot01*dot02))*inv;
    return u>=0 && v>=0 && (u+v)<=1;
  }
  const tris=[];
  let cnt = 0;
  while (V.length>2 && cnt<10000){
    cnt++;
    let earFound=false;
    for(let i=0;i<V.length;i++){
      const i0 = V[(i+V.length-1)%V.length], i1 = V[i], i2 = V[(i+1)%V.length];
      if (triArea(i0,i1,i2) <= 0) continue; // reflex or degenerate
      let anyInside=false;
      for (let k=0;k<V.length;k++){
        const ik = V[k];
        if (ik===i0||ik===i1||ik===i2) continue;
        if (insideTri(P[i0][0],P[i0][1], P[i1][0],P[i1][1], P[i2][0],P[i2][1], P[ik][0],P[ik][1])){ anyInside=true; break; }
      }
      if (anyInside) continue;
      // ear!
      tris.push([i0,i1,i2]);
      V.splice(i,1);
      earFound=true;
      break;
    }
    if (!earFound) break; // probably self-intersecting
  }
  // map back to original indices
  return tris;
}

/* ---------- Wire up UI ---------- */
(function(){
  const $ = sel => document.querySelector(sel);
  const src = document.querySelector('textarea, #src, #in, #input'); // be flexible
  const msg = $('#convMsg');

  function readPts(){
    const raw = src.value || '';
    const pts = parseXYZ(raw);
    const opts = {
      swapYZ: $('#swapYZ')?.checked,
      invertY: $('#invertY')?.checked
    };
    return applyTransforms(pts, opts);
  }

  function save(name, text, mime='text/plain'){
    const a = document.createElement('a');
    a.href = URL.createObjectURL(new Blob([text], {type:mime}));
    a.download = name;
    document.body.appendChild(a); a.click(); a.remove();
  }

  $('#btnOBJpoints')?.addEventListener('click', () => {
    const pts = readPts();
    if (!pts.length){ msg.textContent='No points parsed.'; return; }
    save('funebra_points.obj', objPoints(pts));
    msg.textContent = `OBJ exported as points (${pts.length} vertices).`;
  });

  $('#btnOBJwire')?.addEventListener('click', () => {
    const pts = readPts();
    if (!pts.length){ msg.textContent='No points parsed.'; return; }
    const closeLoop = $('#closeLoop')?.checked;
    save('funebra_wire.obj', objWirePolyline(pts, closeLoop));
    msg.textContent = `OBJ exported as wireframe polyline (${pts.length} vertices${closeLoop?', closed':''}).`;
  });

  // OPTIONAL: if you want a thick ribbon mesh using your existing UI:
  // 1) read thickness from your #thickness input
  // 2) triangulate with ear-clip or fan
  window.funebraExportRibbonOBJ = function(thickness=20, triangulation='ear', closeLoop=true){
    const pts = readPts();
    if (triangulation==='fan'){
      // simple convex fan around centroid
      const cx = pts.reduce((a,p)=>a+p[0],0)/pts.length;
      const cy = pts.reduce((a,p)=>a+p[1],0)/pts.length;
      const cz = pts[0]?.[2]||0;
      const center = [cx,cy,cz];
      const V = [center].concat(pts);
      const F = [];
      for(let i=0;i<pts.length-1;i++) F.push([0,i+1,i+2]);
      if (closeLoop) F.push([0,pts.length,1]);
      save('funebra_fan.obj', objMesh(V,F));
      msg.textContent = `OBJ mesh (fan) exported with ${V.length} verts.`;
      return;
    }
    if (triangulation==='none'){
      // just wireframe
      save('funebra_wire.obj', objWirePolyline(pts, closeLoop));
      msg.textContent = 'OBJ wireframe exported (no triangulation).';
      return;
    }
    // ear-clip on a thickened ribbon (stable on non-convex)
    const ribbon = buildRibbonMesh2D(pts, thickness, closeLoop);
    save('funebra_ribbon.obj', objMesh(ribbon.V, ribbon.F));
    msg.textContent = `OBJ ribbon exported (${ribbon.V.length} verts, ${ribbon.F.length} tris).`;
  };
})();
</script>
