<!doctype html>
<meta charset="utf-8">
<title>Funebra — Point Cloud → OBJ/glTF (points / wire / polygon extrude)</title>

<!-- Basic Metadata -->
<meta name="description" content="Convert X, Y, Z point cloud coordinates into OBJ/glTF with Funebra Math-Art Engine.">
<meta name="keywords" content="Funebra, math art engine, point cloud converter, OBJ, GLTF, 3D viewer, geometry">
<meta name="author" content="Funebra / pLabs Entertainment">

<!-- Open Graph -->
<meta property="og:title" content="Funebra Math-Art Engine – 3D Point Cloud Converter">
<meta property="og:description" content="Paste your coordinates (x, y, z) and export to OBJ or glTF instantly.">
<meta property="og:type" content="website">
<meta property="og:url" content="https://funebra.github.io/math-art-engine/">
<meta property="og:image" content="https://funebra.github.io/math-art-engine/compatibility092025.png">

<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Funebra Math-Art Engine – 3D Point Cloud Converter">
<meta name="twitter:description" content="Paste coordinates and generate OBJ/glTF instantly.">
<meta name="twitter:image" content="https://funebra.github.io/math-art-engine/compatibility092025.png">

<style>
  :root{--bg:#0f1222;--panel:#181b2e;--muted:#aab3c8;--text:#eef3ff}
  body{font:14px system-ui,Segoe UI,Roboto;margin:24px;color:var(--text);background:var(--bg)}
  h3{margin:0 0 .5rem}
  textarea{width:100%;height:240px;border-radius:10px;border:1px solid #2a2f4a;background:#0d1020;color:#eef3ff;padding:10px}
  .row{display:flex;gap:10px;align-items:center;margin:8px 0;flex-wrap:wrap}
  label{white-space:nowrap;opacity:.9}
  input[type=number]{width:110px}
  button{padding:8px 12px;border-radius:10px;border:1px solid #2a2f4a;background:linear-gradient(#1c2140,#131733);color:#e9edff;cursor:pointer}
  button:hover{filter:brightness(1.1)}
  select{padding:6px;border-radius:8px;border:1px solid #2a2f4a;background:#0d1020;color:#e9edff}
  .hint{opacity:.8;margin:.5rem 0}
  pre{background:#0d1020;border:1px solid #2a2f4a;border-radius:10px;padding:10px;white-space:pre-wrap}
</style>

<h3>Paste your lines (format: <code>v x, y, z</code>)</h3>
<textarea id="src" placeholder="v 416.23801506930346, 361.5713484026368, 0
v 412.4760301386069, 363.14269680527354, 0
v 408.7140452079103, 364.7140452079103, 0"></textarea>

<div class="row">
  <label>Thickness (extrude): <input id="th" type="number" value="20" step="1"></label>
  <label>Triangulation:
    <select id="tri">
      <option value="earclip" selected>Ear-clip (safe)</option>
      <option value="fan">Fan (convex)</option>
    </select>
  </label>
  <label><input id="closeLoop" type="checkbox" checked> Close loop (wire/ribbon)</label>
  <label><input id="swapYZ" type="checkbox"> Swap Y/Z</label>
  <label><input id="invertY" type="checkbox"> Invert Y</label>
  <label>Y scale: <input id="yScale" type="number" value="1" step="0.01"></label>
</div>

<div class="row">
  <button id="btnOBJpoints">Export OBJ (Points)</button>
  <button id="btnOBJwire">Export OBJ (Wireframe)</button>
  <button id="toOBJ">Export OBJ (Polygon Extrude)</button>
  <button id="toGLTF">Export glTF (Polygon Extrude)</button>
</div>

<p class="hint">Tip: Points/wire use full 3D (x,y,z). Polygon extrude uses an XY outline (z is ignored) and extrudes by “Thickness”.</p>
<pre id="msg"></pre>

<script>
/* ===== Utilities ===== */
const TAU = Math.PI * 2;
const $ = sel => document.querySelector(sel);
function saveFile(name, text, mime='text/plain'){
  const a = document.createElement('a');
  a.href = URL.createObjectURL(new Blob([text], {type:mime}));
  a.download = name;
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
}

/* ===== Robust parser: accepts 'v x, y, z' OR 'x y z' OR mixed separators ===== */
function parseXYZ(text){
  const pts = [];
  const lines = text.split(/\r?\n/);
  for (let line of lines){
    line = line.trim();
    if (!line) continue;
    line = line.replace(/^[vV]\s+/, '');   // optional 'v'
    line = line.replace(/[,;]+/g, ' ');    // commas/semicolons -> spaces
    const nums = line.match(/[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?/g);
    if (!nums || nums.length < 2) continue;
    const x = +nums[0], y = +nums[1], z = (nums[2]!==undefined) ? +nums[2] : 0;
    if (Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z)) pts.push([x,y,z]);
  }
  return pts;
}

/* ===== Transforms (applied to ALL exports) ===== */
function applyTransforms(pts){
  const swapYZ = $('#swapYZ').checked;
  const invertY = $('#invertY').checked;
  const yScale = +$('#yScale').value || 1;
  const out = [];
  for (const p of pts){
    let [x,y,z] = p;
    if (swapYZ){ [y,z] = [z,y]; }
    y = (invertY ? -y : y) * yScale;
    out.push([x,y,z]);
  }
  return out;
}

/* ===== OBJ helpers ===== */
function objPoints(pts){
  let s = '# funebra points\n';
  s += pts.map(p=>`v ${p[0]} ${p[1]} ${p[2]}`).join('\n')+'\n';
  s += 'p '+ pts.map((_,i)=>i+1).join(' ') + '\n';
  return s;
}
function objWirePolyline(pts, closeLoop){
  let s = '# funebra wireframe\n';
  s += pts.map(p=>`v ${p[0]} ${p[1]} ${p[2]}`).join('\n')+'\n';
  s += 'l ' + pts.map((_,i)=>i+1).join(' ') + (closeLoop ? ' 1' : '') + '\n';
  return s;
}
function objMesh(V,F){
  let s = '# funebra mesh\n';
  s += V.map(v=>`v ${v[0]} ${v[1]} ${v[2]}`).join('\n')+'\n';
  s += F.map(f=>`f ${f[0]+1} ${f[1]+1} ${f[2]+1}`).join('\n')+'\n';
  return s;
}

/* ===== Polygon extrude (uses only XY of the points as an outline) ===== */
function doubleArea2D(pts){ let a=0; for(let i=0;i<pts.length;i++){const j=(i+1)%pts.length; a += pts[i][0]*pts[j][1] - pts[j][0]*pts[i][1]; } return a; }
function ensureCCW2D(pts){ return doubleArea2D(pts) < 0 ? [...pts].reverse() : pts; }
function isConvex2D(a,b,c){ return ((b[0]-a[0])*(c[1]-a[1]) - (b[1]-a[1])*(c[0]-a[0])) > 0; }
function insideTri2D(p,a,b,c){
  const v0=[c[0]-a[0],c[1]-a[1]], v1=[b[0]-a[0],b[1]-a[1]], v2=[p[0]-a[0],p[1]-a[1]];
  const d00=v0[0]*v0[0]+v0[1]*v0[1], d01=v0[0]*v1[0]+v0[1]*v1[1], d02=v0[0]*v2[0]+v0[1]*v2[1];
  const d11=v1[0]*v1[0]+v1[1]*v1[1], d12=v1[0]*v2[0]+v1[1]*v2[1];
  const den = (d00*d11 - d01*d01); if (!den) return false;
  const u=(d11*d02-d01*d12)/den, v=(d00*d12-d01*d02)/den;
  return u>=0 && v>=0 && u+v<=1;
}
function earclip2D(poly){ // poly as [ [x,y], ... ]
  const n=poly.length, V=[...Array(n).keys()], tris=[];
  let guard=0;
  while(V.length>2 && guard++<10000){
    let clipped=false;
    for(let i=0;i<V.length;i++){
      const ia=V[(i-1+V.length)%V.length], ib=V[i], ic=V[(i+1)%V.length];
      const A=poly[ia], B=poly[ib], C=poly[ic];
      if (!isConvex2D(A,B,C)) continue;
      let hit=false;
      for (let k=0;k<V.length;k++){
        const ik=V[k]; if (ik===ia||ik===ib||ik===ic) continue;
        if (insideTri2D(poly[ik],A,B,C)){ hit=true; break; }
      }
      if (hit) continue;
      tris.push([ia,ib,ic]);
      V.splice(i,1);
      clipped=true; break;
    }
    if (!clipped) break; // self-intersecting or degenerate
  }
  return tris;
}
function buildPrismFromOutline(outlineXY, z0, z1, triangulation='earclip'){
  const poly = ensureCCW2D(outlineXY);
  const n = poly.length;
  const pos=[], idx=[];
  const cx = poly.reduce((s,p)=>s+p[0],0)/n, cy = poly.reduce((s,p)=>s+p[1],0)/n;

  // top
  const topCenterIndex = pos.length/3; pos.push(cx,cy,z1);
  const topStart = pos.length/3; for (const p of poly) pos.push(p[0],p[1],z1);
  if (triangulation==='fan'){
    for (let i=0;i<n;i++) idx.push(topCenterIndex, topStart+i, topStart+((i+1)%n));
  } else {
    for (const [a,b,c] of earclip2D(poly)) idx.push(topStart+a, topStart+b, topStart+c);
  }

  // bottom (winding reversed)
  const botCenterIndex = pos.length/3; pos.push(cx,cy,z0);
  const botStart = pos.length/3; for (const p of poly) pos.push(p[0],p[1],z0);
  if (triangulation==='fan'){
    for (let i=0;i<n;i++) idx.push(botCenterIndex, botStart+((i+1)%n), botStart+i);
  } else {
    for (const [a,b,c] of earclip2D(poly)) idx.push(botStart+c, botStart+b, botStart+a);
  }

  // sides
  for (let i=0;i<n;i++){
    const a=i, b=(i+1)%n;
    const ta = topStart+a, tb=topStart+b, bb=botStart+b, ba=botStart+a;
    idx.push(ta,tb,bb,  ta,bb,ba);
  }

  return { positions:new Float32Array(pos), indices:new Uint32Array(idx) };
}
function meshToOBJ(mesh){
  const {positions,indices}=mesh, v=[], f=[];
  for (let i=0;i<positions.length;i+=3) v.push(`v ${positions[i]} ${positions[i+1]} ${positions[i+2]}`);
  for (let i=0;i<indices.length;i+=3)   f.push(`f ${indices[i]+1} ${indices[i+1]+1} ${indices[i+2]+1}`);
  return `# OBJ from Funebra converter\n${v.join('\n')}\n${f.join('\n')}\n`;
}
function toBase64(ab){let s='';const b=new Uint8Array(ab);for(let i=0;i<b.length;i++)s+=String.fromCharCode(b[i]);return btoa(s);}
function minMax3(a){const mn=[+1/0,+1/0,+1/0],mx=[-1/0,-1/0,-1/0];for(let i=0;i<a.length;i+=3){mn[0]=Math.min(mn[0],a[i]);mx[0]=Math.max(mx[0],a[i]);mn[1]=Math.min(mn[1],a[i+1]);mx[1]=Math.max(mx[1],a[i+1]);mn[2]=Math.min(mn[2],a[i+2]);mx[2]=Math.max(mx[2],a[i+2]);}return{min:mn,max:mx};}
function meshToGLTF(mesh){
  const {positions,indices}=mesh;
  const posB=positions.byteLength, idxB=indices.byteLength;
  const buf=new Uint8Array(posB+idxB);
  buf.set(new Uint8Array(positions.buffer),0);
  buf.set(new Uint8Array(indices.buffer),posB);
  const uri=`data:application/octet-stream;base64,${toBase64(buf.buffer)}`;
  const mm=minMax3(positions);
  return JSON.stringify({
    asset:{version:"2.0",generator:"funebra-converter"},
    buffers:[{byteLength:buf.byteLength,uri}],
    bufferViews:[
      {buffer:0,byteOffset:0,byteLength:posB,target:34962},
      {buffer:0,byteOffset:posB,byteLength:idxB,target:34963}
    ],
    accessors:[
      {bufferView:0,byteOffset:0,componentType:5126,count:positions.length/3,type:"VEC3",min:mm.min,max:mm.max},
      {bufferView:1,byteOffset:0,componentType:5125,count:indices.length,type:"SCALAR"}
    ],
    meshes:[{primitives:[{attributes:{POSITION:0},indices:1}]}],
    nodes:[{mesh:0,name:"Extrude"}],
    scenes:[{nodes:[0]}],scene:0
  });
}

/* ===== UI wiring ===== */
const msg = $('#msg');

function readTransformedPoints(){
  const raw = $('#src').value || '';
  const pts = applyTransforms(parseXYZ(raw));
  return pts;
}
function dedupeXYForOutline(pts){
  // remove consecutive duplicates (XY) and drop a trailing duplicate of the first
  const out=[];
  for (const p of pts){
    const last = out[out.length-1];
    if (!last || last[0]!==p[0] || last[1]!==p[1]) out.push(p);
  }
  if (out.length>1){
    const a=out[0], b=out[out.length-1];
    if (a[0]===b[0] && a[1]===b[1]) out.pop();
  }
  return out;
}

/* Points */
$('#btnOBJpoints').addEventListener('click', ()=>{
  const pts = readTransformedPoints();
  if (!pts.length){ msg.textContent='No points parsed.'; return; }
  saveFile('funebra_points.obj', objPoints(pts));
  msg.textContent = `OBJ exported as points (${pts.length} vertices).`;
});

/* Wireframe */
$('#btnOBJwire').addEventListener('click', ()=>{
  const pts = readTransformedPoints();
  if (!pts.length){ msg.textContent='No points parsed.'; return; }
  const closeLoop = $('#closeLoop').checked;
  saveFile('funebra_wire.obj', objWirePolyline(pts, closeLoop));
  msg.textContent = `OBJ wireframe exported (${pts.length} vertices${closeLoop?', closed':''}).`;
});

/* Polygon extrude → OBJ */
$('#toOBJ').addEventListener('click', ()=>{
  const pts = readTransformedPoints();
  const outline = dedupeXYForOutline(pts).map(p=>[p[0],p[1]]);
  if (outline.length < 3){ msg.textContent='Need at least 3 distinct XY points for polygon extrude.'; return; }
  const h = +$('#th').value || 20;
  const tri = $('#tri').value; // 'earclip' | 'fan'
  const mesh = buildPrismFromOutline(outline, -h/2, h/2, tri);
  saveFile('funebra_extrude.obj', meshToOBJ(mesh));
  msg.textContent = `OBJ extrude exported (outline ${outline.length} verts, ${mesh.indices.length/3} tris).`;
});

/* Polygon extrude → glTF */
$('#toGLTF').addEventListener('click', ()=>{
  const pts = readTransformedPoints();
  const outline = dedupeXYForOutline(pts).map(p=>[p[0],p[1]]);
  if (outline.length < 3){ msg.textContent='Need at least 3 distinct XY points for polygon extrude.'; return; }
  const h = +$('#th').value || 20;
  const tri = $('#tri').value;
  const mesh = buildPrismFromOutline(outline, -h/2, h/2, tri);
  saveFile('funebra_extrude.gltf', meshToGLTF(mesh), 'model/gltf+json');
  msg.textContent = `glTF extrude exported (outline ${outline.length} verts, ${mesh.indices.length/3} tris).`;
});
</script>
