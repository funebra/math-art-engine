<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Funebra — Female00 Cartoonizer (OBJ + Subdivision + Toon)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<!-- Use r150 so SubdivisionModifier.js is available -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.150.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.150.0/examples/jsm/"
  }
}
</script>

<style>
  html,body{margin:0;height:100%;background:#0b0b0e;color:#e9f0ff;font:14px/1.4 system-ui,Segoe UI,Roboto,sans-serif;overflow:hidden}
  #ui{
    position:fixed; inset:auto 10px 10px auto; top:10px;
    display:grid; gap:8px; grid-template-columns:1fr 1fr; max-width:380px;
    background:#0f1322cc; border:1px solid #27304d; border-radius:12px; padding:12px; backdrop-filter: blur(6px);
  }
  #ui h3{grid-column:1/-1; margin:0 0 6px; font-size:13px; letter-spacing:0.2px; color:#9fb6ff}
  #ui label{display:grid; grid-template-columns:106px 1fr; align-items:center; gap:8px; font-size:12px; color:#cfe0ff}
  #ui input[type="range"]{width:100%}
  #ui input[type="color"]{width:100%; height:28px; border:0; background:#0000}
  #ui .row{grid-column:1/-1}
  #drop{
    position:fixed; inset:0; pointer-events:none;
    outline:2px dashed transparent; outline-offset:-10px; border-radius:14px;
  }
  #drop.active{pointer-events:none; outline-color:#66aaffaa; background:#3a4a7a22}
  #footer{
    position:fixed; left:10px; bottom:10px; color:#9fb6ff; font-size:12px; opacity:.9;
    background:#0f1322cc; border:1px solid #27304d; border-radius:10px; padding:6px 8px;
  }
  button, input, select{font:12px/1.2 system-ui}
  .btn{cursor:pointer; border:1px solid #384469; background:#1a2040; color:#e9f0ff; padding:6px 10px; border-radius:8px}
  .btn:hover{filter:brightness(1.1)}
  #stage{width:100%;height:100%}
</style>
</head>
<body>
<canvas id="stage"></canvas>

<div id="ui">
  <h3>Female00 — Cartoonizer</h3>

  <label class="row">Load OBJ (file)
    <input id="file" type="file" accept=".obj" />
  </label>

  <label class="row">Load from URL
    <input id="url" type="text" placeholder="https://…/female00.obj" />
  </label>
  <div class="row"><button id="btnUrl" class="btn">Load URL</button>
    <button id="btnExport" class="btn" style="float:right">Export PNG</button></div>

  <label>Subdivisions
    <input id="subd" type="range" min="0" max="3" step="1" value="1" />
  </label>

  <label>Quantize (levels)
    <input id="levels" type="range" min="2" max="8" step="1" value="4" />
  </label>

  <label>Base Color
    <input id="base" type="color" value="#f4b28a" />
  </label>

  <label>Rim Light
    <input id="rim" type="range" min="0" max="2" step="0.01" value="0.8" />
  </label>

  <label>Outline (px)
    <input id="outline" type="range" min="0" max="8" step="0.1" value="2.0" />
  </label>

  <label>Metalness
    <input id="metal" type="range" min="0" max="1" step="0.01" value="0" />
  </label>

  <label>Roughness
    <input id="rough" type="range" min="0" max="1" step="0.01" value="1" />
  </label>
</div>

<div id="footer">Drag & drop an OBJ anywhere • Wheel = zoom • Right-drag = orbit</div>
<div id="drop"></div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
import { SubdivisionModifier } from 'three/addons/modifiers/SubdivisionModifier.js';

const canvas = document.getElementById('stage');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true, preserveDrawingBuffer:true});
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
renderer.setSize(innerWidth, innerHeight);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0b0e);
const camera = new THREE.PerspectiveCamera(48, innerWidth/innerHeight, 0.01, 1000);
camera.position.set(0, 0.6, 2.2);
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

const hemi = new THREE.HemisphereLight(0xcfe7ff, 0x1a1a22, 0.6);
scene.add(hemi);
const key = new THREE.DirectionalLight(0xffffff, 1.2);
key.position.set(1.5, 2.5, 1.5);
scene.add(key);
const fill = new THREE.DirectionalLight(0x8fb2ff, 0.4);
fill.position.set(-2, 1, -1.5);
scene.add(fill);

// ---------- Toon material helpers ----------
function makeGradient(levels=4){
  // build a small 1D gradient map with posterized steps
  const size = 256;
  const data = new Uint8Array(size);
  for (let i=0;i<size;i++){
    const t = i/(size-1);
    const step = Math.floor(t*levels)/Math.max(1,levels-1);
    data[i] = Math.round(step*255);
  }
  const tex = new THREE.DataTexture(data, size, 1, THREE.LuminanceFormat);
  tex.needsUpdate = true;
  tex.minFilter = THREE.NearestFilter;
  tex.magFilter = THREE.NearestFilter;
  tex.generateMipmaps = false;
  return tex;
}
let gradientTex = makeGradient(4);

// outline material reuse
const outlineMat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.BackSide });

let currentRoot = null;

function makeToonMaterial(color, metalness, roughness, rimStrength){
  const mat = new THREE.MeshToonMaterial({
    color: new THREE.Color(color),
    gradientMap: gradientTex
  });
  // Fake rim via onBeforeCompile: add view-facing fresnel term
  mat.onBeforeCompile = (shader)=>{
    shader.uniforms.uRim = { value: rimStrength };
    shader.fragmentShader = shader.fragmentShader.replace(
      '#include <common>',
      `#include <common>
       uniform float uRim;`
    ).replace(
      '#include <lights_fragment_begin>',
      `#include <lights_fragment_begin>
       // Fresnel-ish rim boost
       float rim = pow(1.0 - dot(normalize(vNormal), normalize(vViewPosition)), 2.0);
       diffuseColor.rgb += rim * uRim;`
    );
    mat.userData.shader = shader;
  };
  mat.metalness = metalness;
  mat.roughness = roughness;
  return mat;
}

let toonMat = makeToonMaterial('#f4b28a', 0.0, 1.0, 0.8);

function applyCartoonize(root, subLevels){
  const mod = new SubdivisionModifier(subLevels|0);
  root.traverse(obj=>{
    if(obj.isMesh){
      obj.geometry = obj.geometry.toNonIndexed(); // better edges
      if(subLevels>0){
        obj.geometry = mod.modify(obj.geometry);
      }
      obj.geometry.computeVertexNormals();
      obj.material = toonMat;

      // Outline as a sibling mesh (BackSide + slight expand)
      const outline = new THREE.Mesh(obj.geometry.clone(), outlineMat);
      outline.scale.multiplyScalar(1.0 + (parseFloat(outlineSlider.value)||2)/1000);
      obj.add(outline);
    }
  });
}

// ---------- Loaders ----------
const loader = new OBJLoader();

async function loadFromText(text){
  const obj = loader.parse(text);
  if(currentRoot){ scene.remove(currentRoot); currentRoot.traverse(o=>o.geometry&&o.geometry.dispose()); }
  currentRoot = obj;

  // normalize scale & center
  const box = new THREE.Box3().setFromObject(obj);
  const size = new THREE.Vector3(); box.getSize(size);
  const center = new THREE.Vector3(); box.getCenter(center);
  const maxDim = Math.max(size.x,size.y,size.z)||1;
  const scale = 1.0/maxDim;
  obj.position.sub(center);
  obj.scale.setScalar(scale*1.6);

  scene.add(obj);
  applyCartoonize(obj, parseInt(subd.value,10));
}

async function loadFromURL(url){
  const res = await fetch(url);
  if(!res.ok) throw new Error('Failed to fetch OBJ');
  const text = await res.text();
  await loadFromText(text);
}

// ---------- UI wiring ----------
const subd = document.getElementById('subd');
const levels = document.getElementById('levels');
const base = document.getElementById('base');
const rim = document.getElementById('rim');
const outlineSlider = document.getElementById('outline');
const metal = document.getElementById('metal');
const rough = document.getElementById('rough');

subd.addEventListener('input', ()=> currentRoot && loadFromText(new OBJLoader().parse(loader.parse(currentText)).toString()));
levels.addEventListener('input', ()=>{
  gradientTex = makeGradient(parseInt(levels.value,10));
  toonMat.gradientMap = gradientTex; toonMat.needsUpdate = true;
});
base.addEventListener('input', ()=>{ toonMat.color.set(base.value); });
rim.addEventListener('input', ()=>{ toonMat.userData?.shader && (toonMat.userData.shader.uniforms.uRim.value = parseFloat(rim.value)); });
metal.addEventListener('input', ()=>{ toonMat.metalness = parseFloat(metal.value); toonMat.needsUpdate = true; });
rough.addEventListener('input', ()=>{ toonMat.roughness = parseFloat(rough.value); toonMat.needsUpdate = true; });
outlineSlider.addEventListener('input', ()=>{
  if(!currentRoot) return;
  const f = 1.0 + (parseFloat(outlineSlider.value)||2)/1000;
  currentRoot.traverse(o=>{
    if(o.isMesh && o.material===toonMat){
      const back = o.children.find(c=>c.material===outlineMat);
      if(back) back.scale.setScalar(f);
    }
  });
});

// File picker
let currentText = '';
document.getElementById('file').addEventListener('change', async (e)=>{
  const file = e.target.files?.[0]; if(!file) return;
  const text = await file.text(); currentText = text;
  loadFromText(text);
});

// URL load
document.getElementById('btnUrl').addEventListener('click', ()=>{
  const u = document.getElementById('url').value.trim();
  if(u) loadFromURL(u).catch(err=>alert(err.message));
});

// Drag & drop
const drop = document.getElementById('drop');
window.addEventListener('dragover', e=>{ e.preventDefault(); drop.classList.add('active'); });
window.addEventListener('dragleave', e=>{ drop.classList.remove('active'); });
window.addEventListener('drop', async e=>{
  e.preventDefault(); drop.classList.remove('active');
  const file = [...e.dataTransfer.files].find(f=>/\.obj$/i.test(f.name));
  if(file){ const text = await file.text(); currentText = text; loadFromText(text); }
});

// Export PNG
document.getElementById('btnExport').addEventListener('click', ()=>{
  const url = renderer.domElement.toDataURL('image/png');
  const a = Object.assign(document.createElement('a'), { href:url, download:'female00-cartoon.png' });
  a.click();
});

// Animate
function onResize(){ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); }
addEventListener('resize', onResize);

(function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
})();
</script>
</body>
</html>
