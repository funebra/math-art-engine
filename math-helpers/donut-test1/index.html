<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Funebra Donut – stable test</title>
<style>
  html,body{height:100%} body{margin:0;background:#0b0c10;color:#e6e9f0;font:14px system-ui}
  #c{display:block;width:100%;height:100%}
  .hud{position:fixed;right:10px;top:10px;background:#0009;padding:8px 10px;border:1px solid #ffffff22;border-radius:10px}
</style>

<!-- Three.js via import map -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>
<body>
<canvas id="c"></canvas>
<div class="hud"><label><input id="auto" type="checkbox" checked> auto-rotate</label></div>

<!-- 1) SHIM: create global Funebra BEFORE loading your engine -->
<script>
  window.Funebra = window.Funebra || {};
  Funebra.surfaces = Funebra.surfaces || {};
</script>

<!-- 2) Your engine (it expects Funebra to exist) -->
<script src="https://funebra.github.io/math-art-engine/script.js"></script>

<!-- 3) Donut code -->
<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

/* One renderer on one canvas (avoid double contexts) */
const canvas = document.getElementById("c");
const gl = canvas.getContext("webgl", { antialias:true, alpha:false, premultipliedAlpha:true });
const renderer = new THREE.WebGLRenderer({ canvas, context: gl });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight, false);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0c10);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0, 0.8, 3.2);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.autoRotate = true;
controls.autoRotateSpeed = 0.9;

addEventListener("resize", ()=>{
  renderer.setSize(innerWidth, innerHeight, false);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
});

/* Lights (keep it simple for now; HDRI optional) */
scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 1.1));
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(2,3,4);
scene.add(dir);

/* Engine arrays -> THREE.BufferGeometry */
function toThreeGeometry(raw){
  if (raw?.isBufferGeometry) return raw;

  const geo = new THREE.BufferGeometry();
  const pos = new Float32Array(raw.positions);
  geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));

  if (raw.uvs) geo.setAttribute("uv", new THREE.BufferAttribute(new Float32Array(raw.uvs), 2));

  // pick 16-bit or 32-bit index based on vertex count + support
  const vertCount = pos.length / 3;
  const need32 = vertCount > 65535;
  const has32  = renderer.capabilities.isWebGL2 || renderer.extensions.get("OES_element_index_uint");

  if (raw.indices) {
    const IndexArray = (need32 && has32) ? Uint32Array : Uint16Array;
    geo.setIndex(new THREE.BufferAttribute(new IndexArray(raw.indices), 1));
  }
  if (raw.normals) geo.setAttribute("normal", new THREE.BufferAttribute(new Float32Array(raw.normals), 3));
  else geo.computeVertexNormals();

  return geo;
}

/* Torus parametric (use engine helper if present, else fallback) */
const torusFn = (Funebra.surfaces?.torus?.({R:1.15, r:0.44})) || ((u,v)=>{
  const U=u*Math.PI*2, V=v*Math.PI*2, cx=Math.cos(U), sx=Math.sin(U), cv=Math.cos(V), sv=Math.sin(V);
  const R=1.15, r=0.44; return {x:(R+r*cv)*cx, y:(R+r*cv)*sx, z:r*sv};
});

/* Keep under 65k verts to be WebGL1-safe regardless of extensions */
const nu = 320, nv = 160; // 51,200 verts
const raw = Funebra.makeParametric3D ? Funebra.makeParametric3D(torusFn, {nu, nv}) : null;

/* If engine didn’t provide it, synthesize quickly */
const geo = raw ? toThreeGeometry(raw) : new THREE.TorusGeometry(1.15, 0.44, 64, 220);

/* Materials */
const doughMat = new THREE.MeshPhysicalMaterial({
  color: 0xAD7A4E, roughness: 0.85, metalness: 0.0, sheen: 0.25, sheenRoughness: 0.9
});
const glazeMat = new THREE.MeshPhysicalMaterial({
  color: 0xF7B5D5, roughness: 0.25, clearcoat: 1.0, clearcoatRoughness: 0.08, ior: 1.45
});

/* Meshes — share geometry (no .clone()) */
const dough = new THREE.Mesh(geo, doughMat);
const glaze = new THREE.Mesh(geo, glazeMat);
glaze.scale.setScalar(1.01);

/* Glaze mask + gentle drips (shader tweak) */
glaze.onBeforeCompile = (shader)=>{
  shader.uniforms.uTime = {value:0};
  shader.uniforms.uCut  = {value:0.06};
  shader.uniforms.uAmp  = {value:0.055};
  shader.uniforms.uFreq = {value:10.0};
  shader.vertexShader = shader.vertexShader
    .replace('#include <common>', '#include <common>\n varying vec3 vPos;')
    .replace('#include <begin_vertex>', '#include <begin_vertex>\n vPos = transformed;');
  shader.fragmentShader = shader.fragmentShader
    .replace('#include <common>',
`#include <common>
varying vec3 vPos;
uniform float uTime,uCut,uAmp,uFreq;
float h(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}
float n2(vec2 p){vec2 i=floor(p),f=fract(p);
 float a=h(i),b=h(i+vec2(1,0)),c=h(i+vec2(0,1)),d=h(i+vec2(1,1));
 vec2 u=f*f*(3.-2.*f);
 return mix(a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y;}
`)
    .replace('#include <output_fragment>',
`float ang = atan(vPos.y, vPos.x);
float drip = n2(vec2(ang*uFreq, 0.0) + uTime*0.3);
float cut = uCut + (drip-0.5)*uAmp;
if (vPos.z < cut) discard;
#include <output_fragment>`);
  glaze.userData.shader = shader;
};

/* Sprinkles */
const sprinkleGeo = new THREE.CapsuleGeometry(0.007, 0.04, 2, 6);
const sprinkleMat = new THREE.MeshPhysicalMaterial({roughness:0.35, clearcoat:0.6, clearcoatRoughness:0.2});
const sprinkles = new THREE.InstancedMesh(sprinkleGeo, sprinkleMat, 420);
scene.add(sprinkles);
const palette=[0xff4d6d,0x6ae3ff,0xffe066,0x8cff7a,0xc69cff,0xffffff];
const dummy=new THREE.Object3D(), color=new THREE.Color();
for(let i=0;i<sprinkles.count;i++){
  const U=Math.random()*Math.PI*2, V=(Math.random()*0.6+0.4)*Math.PI*2;
  const R=1.15,r=0.44, cx=Math.cos(U),sx=Math.sin(U), cv=Math.cos(V),sv=Math.sin(V);
  const x=(R+r*cv)*cx, y=(R+r*cv)*sx, z=r*sv;
  dummy.position.set(x,y,z);
  const n=new THREE.Vector3(cv*cx,cv*sx,sv).normalize();
  dummy.lookAt(dummy.position.clone().add(n));
  dummy.rotateX(Math.PI*0.5);
  dummy.scale.setScalar(1+Math.random()*0.3);
  dummy.updateMatrix();
  sprinkles.setMatrixAt(i, dummy.matrix);
  color.setHex(palette[(Math.random()*palette.length)|0]);
  sprinkles.setColorAt(i, color);
}
sprinkles.instanceColor.needsUpdate = true;

/* Group + loop */
const group = new THREE.Group();
group.add(dough, glaze);
scene.add(group);

document.getElementById('auto').addEventListener('change', e=> controls.autoRotate = e.target.checked);

const clock = new THREE.Clock();
renderer.setAnimationLoop(()=>{
  const t = clock.getElapsedTime();
  if (glaze.userData.shader) glaze.userData.shader.uniforms.uTime.value = t;
  if (controls.autoRotate) group.rotation.y += 0.003;
  controls.update();
  renderer.render(scene, camera);
});
</script>
</body>
</html>

